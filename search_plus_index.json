{"./":{"url":"./","title":"GinBook","keywords":"","body":"1. GinBook1.1. 章节介绍1.2. 其他1. GinBook ​ 与某周天子随口约的Gin入门级教程，经过寒假摆了一假期后在2022春随缘更新。 ​ 面向对象为有一定的Go语言基础，没有的可以去看看菜鸟教程有关于Go的入门。看懂语法后经过一些项目的学习，相信你就可以阅读并加以学习这不太专业的Ginbook了。当然，为了当读者结合实例学习，本项目除了推荐的几个优秀项目外，还会给出初步的Gin-demo实例项目，相对成熟的项目可以参考 Phoenix-server ，让读者能够结合一整个项目实例的角度来对本GinBook有着更好的理解。 ​ 而本项目的定位为简单的gin项目搭建使用，使用上相对简单，不过相较于一些优秀的项目还是相去甚远，不过作为正常学生的后端项目想必还是相对足够的。希望大家看完本教程后能了解到这一基本结构并能自行上手Gin这门语言。受时间与篇幅限制本Ginbook难以讲到所有的用法，只能介绍一些常见的应用,更多相关内容的学习可以参见各章节的参考链接进行学习。 1.1. 章节介绍 因个人（BFlame）只是初学者，学习使用Gin的时候并不系统，因此学习到该高星项目 后，决定本Ginbook的顺序以该组织推送的教程为基准进行。如下所示 ✅ 第一章：gin的学习前准备工作 hello gin ✅ 第二章：gin的get post delete put请求以及获取参数的方式 ✅ 第三章：使用bind绑定参数和参数验证 ✅ 第四章：gin对于文件的上传和返回 ✅ 第五章：gin的中间件和路由分组 ✅ 第六章：日志介绍以及工具推荐 ✅ 第七章：初识GORM使用GORM进行数据库操作 ✅ 第八章：jwt-go详细教学及使用示例 ✅ 第N章：elasticsearch 简单指南，以go为例 1.2. 其他 版权归 BFlameSwift 所有。未经授权不得转载。 使用utteranc.es评论插件，需要刷新页面一下方可使用 主要作者ly目前去考盐了，因此考盐前暂停维护哈，欢迎提pr来修改和丰富内容~ By BFlameSwift，使用知识共享 署名-相同方式共享 4.0协议发布            updated 2022-10-22 07:49:13 "},"post-preparation/di-yi-zhang-gin-jie-shao.html":{"url":"post-preparation/di-yi-zhang-gin-jie-shao.html","title":"第一章 Gin介绍","keywords":"","body":"1. Gin介绍1.1.1. Gin 是什么1.1.2. 为什么选择Gin1.1.3. 参考 1. Gin介绍 1.1.1. Gin 是什么 Gin是一个golang的微框架，封装比较优雅，API友好，源码注释比较明确，具有快速灵活，容错方便等特点 对于golang而言，web框架的依赖要远比Python，Java之类的要小。自身的net/http足够简单，性能也非常不错 借助框架开发，不仅可以省去很多常用的封装带来的时间，也有助于团队的编码风格和形成规范 1.1.2. 为什么选择Gin 国外如Google、AWS、Cloudflare、CoreOS等，国内如七牛、阿里、字节等都已经开始大规模使用Golang开发其云计算相关产品。 相较于Springboot，Gin的上手难度低，Go语言总体语法上与C类似，很快就能学会。并且在内存、qps、部署后包大小上相较于Springboot均有不小的提升[1]。go使用mod管理包极为方便，且目前个人已知下包与平台无关，参见pywin32。 相较于Django，go语言轻快的优势体现的较明显。go在速度上比起python快上很多，通常高一个数量级左右。并且在包管理上比起django还要方便。Go的旗号是为并发而生，django最大的并发量也不过300，而go的并发量在一般功能下可以破万。此外Gin的配置简单，有一个基本的结构后便可轻松上手，而个人觉得Django配置相对繁琐，例如跨域问题等。部署上相对Django也简单很多，打包运行即可，而Django仍要进行一定配置。 不过Gin相对于Django的缺点也比较明显，Go语言相对年轻，语法糖并不成熟，泛型也是在2022年的1.18版本中刚刚添加，很多代码可能会写的相对丑陋。 1.1.3. 参考 go gin框架和springboot框架WEB接口性能对比 By BFlameSwift，使用知识共享 署名-相同方式共享 4.0协议发布            updated 2022-10-22 07:49:13 "},"post/preparation/huan-jing-pei-zhi.html":{"url":"post/preparation/huan-jing-pei-zhi.html","title":"环境配置","keywords":"","body":"1. 环境配置1.1. 安装1.2. 配置环境变量1.2.1. 推荐设置1.3. Hello，world！！1.4. Go web开发1.4.1. 参考1. 环境配置 1.1. 安装 在官网下载Go https://golang.google.cn/dl/ 设置安装目录一路安装即可 1.2. 配置环境变量 配置GOPATH和GOROOT 其中GOPATH是存放Go的主要路径， GOPATH/bin 存放Go install * 命令的文件，后续提到swagger会用到 GOROOT是Go的根目录 并将$GOROOT/bin、$GOPATH/bin添加系统变量PATH： 现在即可以通过 go version 查看Go语言版本 1.2.1. 推荐设置 Go env setting go env -w GOPROXY=https://goproxy.cn,direct 七牛设置的代理，设置后可大大提升安装包的速度！！！ IDE配置 主要有Goland和Vscode 推荐使用vscode主要插件:Go , 使用后可自动删除未使用的import 并处理代码格式 安装后可使用 ctrl+shift+P 输入从而更新包 当然也可以使用 go get -u all 来更新Go 1.3. Hello，world！！ — 一切的开始 package main import \"fmt\" func main() { fmt.Println(\"Hello, world\") } 使用 go run main.go (文件名） 即可运行，注意运行单文件的包名需要是main 好了，你已经会写 hello, world 了，那么现在来用Go语言完成本学习的学术分享平台吧！！！（×） 1.4. Go web开发 主要使用Gin框架，下图是Go开发中主要的项目结构，不过多介绍了 PS 图来自《Go高级编程》 5.7 大型Web项目分层(侵删） 下面使用一个Gin的简单程序 package main import \"github.com/gin-gonic/gin\" func main() { r := gin.Default() r.GET(\"/\", func(c *gin.Context) { c.JSON(200, gin.H{ \"message\": \"success\", }) }) r.Run(\":8000\") } 如果项目中不存在 go.mod 文件需要使用 go mod init 生成mod文件，而后使用 go mod tidy 安装依赖。使用 go run main.go 运行即可，访问 localhost:8000/ 查看到message 表示链接成功 好了，你已经真正的学会了如何用 Gin 开发Web程序，下面开始你的Go之旅吧！！ 展望（小声） 后面可能会把Go配置Elastic Search的过程弄一下，以及在涉及到 Go处理并发时会出一下学习笔记 1.4.1. 参考 摘自个人博客 By BFlameSwift，使用知识共享 署名-相同方式共享 4.0协议发布            updated 2022-10-22 07:49:13 "},"post/preparation/ru-men-jiao-cheng-tui-jian.html":{"url":"post/preparation/ru-men-jiao-cheng-tui-jian.html","title":"入门教程推荐","keywords":"","body":"1. 入门教程推荐1.1. Go入门教程推荐1.2. 推荐项目1.3. 博客推荐1.4. 官方文档（推荐）1. 入门教程推荐 1.1. Go入门教程推荐 GO语言圣经，入门语法必备：《Go程序设计语言》 [菜鸟教程](https://www.runoob.com/go/go-tutorial.html) 《Go语言实战》，经典的实战类书籍 《Go Web编程》 基本覆盖开发需求：session，请求、数据库、部署。可以当做参考书来用 《Go语言高级编程》 书的附录A中提到的Go常见坑很实用 速成的话个人推荐菜鸟教程，随后看《Go程序设计语言》，并结合一些项目实例学习 1.2. 推荐项目 Gin官方推荐项目 go-gin-api gin-vue-admin xpertise-go 学长的项目：本项目结构的最初来源。码风很好 Phoenix-server 推荐，也是本项目的主要参考对象 1.3. 博客推荐 Go-gin-api的文档 https://github.com/xinliangnote/Go https://eddycjy.com/ 其他人的Ginbook https://www.topgoer.com/gin%E6%A1%86%E6%9E%B6/ 1.4. 官方文档（推荐） 英文文档：https://gin-gonic.com/docs/quickstart/ 中文文档：https://gin-gonic.com/zh-cn/docs/quickstart/ By BFlameSwift，使用知识共享 署名-相同方式共享 4.0协议发布            updated 2022-10-22 07:49:13 "},"post/preparation/3.html":{"url":"post/preparation/3.html","title":"Gin项目大致结构","keywords":"","body":"1. Gin项目大致结构1.1. Gin 后端项目结构1.1.1. 流程大致介绍1.2. 参考1. Gin项目大致结构 1.1. Gin 后端项目结构 本结构大体参照于项目 ， 实际使用时或有不同，暂时以该个人项目为准，后续可能会更换代码风格更好的项目作为参考。不过大体上的结构类似。 结合代码使用或许更佳。 值得注意的是，由于面向人群大多为初学Gin的同学，此处结构中没有出现/internal，/pkg 等文件夹，分别代表 私有应用程序和库代码以及 外部应用程序可以使用的库代码，具体理解和使用可见[2]。将功能按照文件夹所大致区分开。并且由于笔者并未进过企业后端实习，水平仍停留在学生水平。因此可能有亿点不成熟之处还行给出建议修改。 此外企业上的Go项目大多才用微服务的kit框架详解(基于go-kit)，本例专注于小型后端开发，固也有所不同吧。 Gin-demo ├── api (api层) │ └── v1 (v1版本接口) │ └── user.go ├── config │ ├── example.yml (配置文件样例) │ ├── gorm.go (gorm数据库初始化) │ └── viper.go (viper初始化) ├── demo.log ├── demo.yml (配置文件) ├── docs (swagger文档目录) ├── global (全局对象) │ └── global.go ├── go.mod ├── go.sum ├── logs (日志存储) │ ├── demo.log.20220427.log ├── main.go ├── middleware (中间件层) │ ├── auth.goo (权限验证) │ ├── cors.go │ └── logrus.go (logrus日志) ├── model │ ├── database (入参结构体) │ │ └── user.go │ └── response (出参结构体) │ └── user.go ├── resource (静态资源文件夹) ├── router │ └── router.go (路由信息) ├── service (service层，为api提供Helper或数据库服务) │ └── user.go ├── storage │ └── initialize.go (初始化) ├── test (测试) └── utils (工具包) 此时以当前较新版本 为准， 1.1.1. 流程大致介绍 当前端发来请求，后端通过router来找到对应的路由，并进行必要的中间件方法调用middleware。简单中间件auth鉴权后，进入API，当API接口来验证(BindAndValid) 参数response格式是否正确。在API处适当的调用service处的方法，为API提供Helper或是数据库操作，其中不免用到model/databse数据库对象。并返回对应处理，顺便通过中间件记录日志到logs。 后端开始运行时 运行main.go调用config中的各方法来初始化路由、全局变量(global)数据库DB、Viper（读取配置文件），记录日志。 随后简单介绍Config 中的一些用作项目初始化的函数。 Config.InitRouter 初始化路由信息，将你的路由按照特定规则放置其中即可。具体会在第五章中讲到。 Config.InitViper 主要用于读取存储一些全局信息，viper 可直接读取各种类型的配置文件，本demo用于读取YAML文件。具体简单使用方式见config/viper.go 。 此时我们读取数据库信息用以连接数据库。在demo项目根目录创建demo.yaml格式如下。 database: ip: '127.0.0.1' # MySQL的IP地址 port: '3306' # MySQL的端口 user: 'username' # MySQL的用户名 password: 'password' # MySQL对应用户的密码 database: 'dbname' # 使用的MySQL数据库名称 jwt: # token 密钥，生产环境时记得修改 secret: 'demo@' # token 过期时间 单位：秒 timeout: 3600 server: backend_url: 'http://127.0.0.1:8081/api/v1' 使用v.Set(\"root_path\", rootPath) 在对全局变量viper中放置root_path, 而读取则使用dbstr := global.VP.GetString(\"database.ip\") 来访问上述数据库中的ip信息。其余类推即可。 Config.InitMySQL 用作初始化连接远程Mysql数据库。在填写好上述信息时，正常来讲便可直接运行项目了，访问http://127.0.0.1:8000/ 可看到如下提示： 而当你需要添加其他表到数据库中时，你需要在initialize/gorm.go 中 添加其他表的信息，类似如&model.Post{}, 来让gorm生成其余表项。 err = db.AutoMigrate( &model.User{}, ) 1.2. 参考 https://github.com/golang-standards/project-layout https://travisjeffery.com/b/2019/11/i-ll-take-pkg-over-internal/ By BFlameSwift，使用知识共享 署名-相同方式共享 4.0协议发布            updated 2022-10-22 07:49:13 "},"post-preparation/hello-gin.html":{"url":"post-preparation/hello-gin.html","title":"Hello,Gin!","keywords":"","body":"1. Hello,Gin!1. Hello,Gin! 一个简单的Web服务器代码如下,在下面的代码中，使用go run main.go运行，即可通过访问 127.0.0.1:8081/ping 即可查到看HelloGin的提示。 package main import \"github.com/gin-gonic/gin\" func main() { r := gin.Default() r.GET(\"/ping\", func(c *gin.Context) { c.JSON(200, gin.H{\"message\": \"HelloGin\"}) }) r.Run(\":8081\") } 从上面代码中我们可以发现几个部分 路由注册：通过r.GET 使用Get方法，（其他的POST、DELETE、PUT方法同理）来注册路由/ping ,并紧接着对应调用的方法。 运行信息，本次后端监听了8081端口，而默认设置为8080。 默认Engine实例，此处指Engine实例，表示使用官方的Logger，Recovery中间件来创建实例，后续我们会使用Logrus来作为日志中间件。 By BFlameSwift，使用知识共享 署名-相同方式共享 4.0协议发布            updated 2022-10-22 07:49:13 "},"post/basis/gin-de-qing-qiu-yi-ji-huo-qu-can-shu-de-fang-shi.html":{"url":"post/basis/gin-de-qing-qiu-yi-ji-huo-qu-can-shu-de-fang-shi.html","title":"第二章 gin的请求以及获取参数的方式","keywords":"","body":"1. 第二章 gin的请求以及获取参数的方式1. 第二章 gin的请求以及获取参数的方式 ​ 上一节HelloGin中说到，注册路由后，来选择对应调用的方法。本小节主要介绍如何来接收并简单处理前端所送来的请求的。 以一简单的登录处理程序为例： func Login(c *gin.Context) { username := c.Request.FormValue(\"username\") password := c.Request.FormValue(\"password\") // 处理登录信息 c.JSON(http.StatusOK, gin.H{ \"success\": true, \"message\": \"登录成功\", \"code\": 200 , \"data\": \"username:\" + username + \"password\" + password, }) } 首先c *gin.Context 表示上下文信息，也就是其中包含了前端发给我们的数据。此处使用c.Request.FormValue(\"username\") 来获取前端以username为key的内容并转为字符串形式。 此处便可应对大多情况，后端可能还会按需将字符串格式化为其他形式例如数组、字典等。处理完成后以JSON形式返回信息给前端。 此外，Gin还可接收路由中的特定信息，例如对下面这条路由信息时 userRouter.GET(\"/:id\", v1.GetUser) 可对应使用来获取指定的id id := c.Param(\"id\") 只用这种方式大致可以处理绝大多数情况了。下一小节将会介绍通过bind绑定参数来使得一行接收到所有的信息并进行简单验证。但是一次只能接收到一个参数（纯压行也不是一个好办法），还需要额外的对参数进行验证。若只是这么粗暴处理往往会导致api接口函数过于冗长。 否则便可能会像我一样曾经在api接口函数中写下了80行接收并验证参数的蠢事。。 By BFlameSwift，使用知识共享 署名-相同方式共享 4.0协议发布            updated 2022-10-22 07:49:13 "},"post-basis/swagger-jie-shao.html":{"url":"post-basis/swagger-jie-shao.html","title":"Swagger 介绍","keywords":"","body":"1. Swagger 介绍1.1.1. swagger 是什么1.1.2. 安装1.1.3. 命令使用1.1.4. 具体使用1.1.5. 效果1. Swagger 介绍 1.1.1. swagger 是什么 ​ Swagger 是一个规范且完整的框架，用于生成、描述、调用和可视化 RESTful 风格的 Web 服务。 ​ Swagger 的目标是对 REST API 定义一个标准且和语言无关的接口，可以让人和计算机拥有无须访问源码、文档或网络流量监测就可以发现和理解服务的能力。当通过 Swagger 进行正确定义，用户可以理解远程服务并使用最少实现逻辑与远程服务进行交互。与为底层编程所实现的接口类似，Swagger 消除了调用服务时可能会有的猜测。 ​ 直观来讲，后端可依次来维护接口文档，相较于word维护省时省力。并方便实施测试。 Swagger 的优势 支持 API 自动生成同步的在线文档：使用 Swagger 后可以直接通过代码生成文档，不再需要自己手动编写接口文档了，对程序员来说非常方便，可以节约写文档的时间去学习新技术。 提供 Web 页面在线测试 API：光有文档还不够，Swagger 生成的文档还支持在线测试。参数和格式都定好了，直接在界面上输入参数对应的值即可在线测试接口。 1.1.2. 安装 在此之前仍要确保将GOROOT、GOPATH加入到环境变量。并默认使用的是Go的最新版 官方网址： swag go install github.com/swaggo/swag/cmd/swag@latest 1.1.3. 命令使用 swag init 生成swag文档，不加参数的话自动生成到 ./docs 中，其中的内容全部由swag生成。 swag fmt 使用fmt格式化 SWAG 注释。(请先升级到最新版本) 主要使用以上两个就可以了，更具体使用也可参见官方中文README 1.1.4. 具体使用 由于在initialize/router中导入swagger 并注册了一下路由后，运行gin-demo 即可在127.0.0.1:8081/swagger 访问到swagger文档了。 import （ginSwagger \"github.com/swaggo/gin-swagger\" _ \"github.com/Super-BUAA-2021/Gin-demo/docs\"） // 重要 r.GET(\"/swagger/*any\", ginSwagger.WrapHandler(swaggerFiles.Handler)) 当然在需要添加swagger的api接口上方添加指定格式的注释。再使用swag init 生成文档重新运行即可。 下面给出一个API接口代码及其上方的Swagger注释 // Login // @Summary 用户登录 // @Description 根据用户邮箱和密码等生成token，并将token返回给用户 // @Tags 登录模块 // @Accept json // @Produce json // @Param data body model.LoginQ true \"用户名，密码\" // @Success 200 {string} string \"{\"success\": true, \"message\": \"登录成功\", \"data\": \"model.User的所有信息\"}\" // @Router /api/v1/login [post] func Login(c *gin.Context) { // var user model.User // var notFound bool var data model.LoginQ if err := c.ShouldBindJSON(&data); err != nil { panic(err) } c.JSON(http.StatusOK, gin.H{ \"success\": true, \"message\": \"登录成功\", \"data\": \"username:\" + data.Username + \",password:\" + data.Password, }) } 此处主要解释下Param中的model.LoginQ 为前端发送参数的结合体。其内容为，在对参数进行bind验证（下节细说）后，便可直接调用使用了，也初步验证了参数的类型、数量是否合法。 type LoginQ struct { Username string `json:\"username\"` Password string `json:\"password\"` } PS 还有两种常见方式可自行使用,第一种query主要用于前端在url上添加参数使用。后一种FormData主要用于前端传输文件至后端。更多还请参见官方文档 // @Param id query int true \"Account ID\" id := c.Request.URL.Query().Get(\"id\") // @Param code formData file true \"代码文件\" 1.1.5. 效果 前端或后端可直接通过此界面来想指定位置发送请求以测试。 运行请求结果 By BFlameSwift，使用知识共享 署名-相同方式共享 4.0协议发布            updated 2022-10-22 07:49:13 "},"post-basis/di-san-zhang-shi-yong-bind-bang-ding-can-shu-he-can-shu-yan-zheng.html":{"url":"post-basis/di-san-zhang-shi-yong-bind-bang-ding-can-shu-he-can-shu-yan-zheng.html","title":"第三章：使用bind绑定参数和参数验证","keywords":"","body":"1. 第三章：使用bind绑定参数和参数验证1.1. bind-data basic1.2. validator1.3. 结语1.4. 参考1. 第三章：使用bind绑定参数和参数验证 首先举一个不恰当的例子，当某个API具有很多种参数时，例如下面这种。 // AdvancedSelectPaper doc // @description es 高级检索筛选论文，包括对文章类型journal的筛选，页数的更换,页面大小size的设计, \\n 错误码：401 参数格式错误, 排序方式1为默认，2为引用率，3为年份 // @Tags elasticsearch // @Param conditions formData string true \"conditions 为条件，表示字典的列表：type 123表示运算符must or，not，\" // @Param min_date formData string true \"min_date\" // @Param max_date formData string true \"max_date\" // @Param page formData int true \"page\" // @Param size formData int true \"size\" // @Param doctypes formData string true \"doctypes\" // @Param conferences formData string true \"conferences\" // @Param journals formData string true \"journals\" // @Param publishers formData string true \"publishers\" // @Param sort_type formData int true \"sort_type\" // @Param sort_ascending formData bool true \"sort_ascending\" // @Success 200 {string} string \"{\"success\": true, \"message\": \"获取成功\"}\" // @Failure 500 {string} string \"{\"success\": false, \"message\": \"错误500\"}\" // @Router /es/select/paper/advanced [POST] 若你对每一个参数在注释时都一条条的注释，并且才取参数的时候也一条一条的取，例如page_str := c.Request.FormValue(\"page\")， 此时显然是一段很臭并且不利于编写的代码。此外，大多数情况，参数还存在着非法情况，当遇到如此多的参数，并且若是存在着参数格式不正确，自然也不能一条条的if-else 的验证。在Django中，有着Form的处理方式，而在Gin中则是有bind-data来验证数据，并有validator 来对指定字段值进行验证。 1.1. bind-data basic 相对应在刚刚介绍的Swagger中，使用如下方式来传递一组参数，上一戒中也介绍过，model.LoginQ自行定义在model包中，此时Swagger注释便美观多了。 // @Param data body model.LoginQ true \"用户名，密码\" 其中LoginQ内容如下 type LoginQ struct { Username string `json:\"username\"` Password string `json:\"password\"` } 基本使用方式见下，创建data LoginQ类型，使用ShouldBindJson方法将json格式的信息按照LoginQ转化到data中。 PS：若传输的信息中含有非Json信息，请使用ShouldBind ，而BindJson、Bind与ShouldBindJson、ShouldBind的区别则是是否返回错误信息以供调试。个人建议使用Should。 var data model.LoginQ if err := c.ShouldBindJSON(&data); err != nil { panic(err) } 当然若是每次传递参数都使用如上三行来套模板也有些“臭”。下面简单封装一下上述代码，在utils/gin.go 中添加如下代码.(utils 在我的理解中可以存放一些工具类的函数) 首先先放置一个简单版，尽可对Json进行判断并不返回错误信息。 func BindAndValid(c *gin.Context, model interface{}) interface{} { if err := c.ShouldBindJSON(&model); err != nil { _, file, line, _ := runtime.Caller(1) panic(file + \"(line \" + strconv.Itoa(line) + \"): bind model error\") } return model } 而在原来的获取参数部分，则可直接获取 data := utils.BindAndValid(c, &model.LoginQ{}).(*model.LoginQ) 随后使用data.username 即可调用。 1.2. validator 开源项目go-playground/validator是一个基于标签对结构体和字段进行值验证的验证器， 我们依此来作为参数校验。 获取方式 go get github.com/go-playground/validator/v10 下面给出部分常用的标签，具体使用仍需查看官网文档，更详细的中文使用参见url 标签 含义 required 必填 gt 大于 gte 大于等于 lt 小于 lte 小于等于 min 最小值 max 最大值 oneof 参数集内的其中之一 len 长度要求与 len 给定的一致 于是我们对LoginQ进行修改，增加了binding 其中username表示长度3-100，必填，而password表示长度大于等于6必填 type LoginQ struct { Username string `json:\"username\" binding:\"min=3,max=100,required\"` Password string `json:\"password\" binding:\"gte=6,required\"` } 注：由于gin内置了validator v10于是使用binding，正常应使用：validator:required 并修改原函数。以及更改ShouldBindAndValid函数，让其当验证错误时返回错误信息。 func ShouldBindAndValid(c *gin.Context, model interface{}) error { if err := c.ShouldBind(&model); err != nil { return err } return nil } func Login(c *gin.Context) { var data model.LoginQ{} if err := utils.ShouldBindAndValid(c, &data);err != nil { c.JSON(http.StatusOK, gin.H{ \"success\": false, \"message\": \"参数信息不合法\" + err.Error(), }) return } c.JSON(http.StatusOK, gin.H{ \"success\": true, \"message\": \"登录成功\", \"data\": \"username:\" + data.(*model.LoginQ).Username + \",password:\" + data.(*model.LoginQ).Password, }) } 当输入格式不规范时,该接口返回信息： { \"password\": \"st\", \"username\": \"string\" } Response body { \"message\": \"参数信息不合法Key: 'LoginQ.Password' Error:Field validation for 'Password' failed on the 'gte' tag\", \"success\": false } PS 可在ShoudBindAndValid 中添加翻译器使其翻译成中文报错，读者可自行尝试。 1.3. 结语 本小节简单介绍了bind-data，以及验证器go validator的使用方法并给出了简单实例。相信聪明的你肯定学会了吧。 1.4. 参考 Go 使用validator进行后端数据校验 go validator gin的各种获取请求方式的介绍 By BFlameSwift，使用知识共享 署名-相同方式共享 4.0协议发布            updated 2022-10-22 07:49:13 "},"post-basis/p4-upload-file.html":{"url":"post-basis/p4-upload-file.html","title":"第四章：gin对于文件的上传和返回","keywords":"","body":"1. 第四章：gin对于文件的上传和返回1.1. 文件上传1.2. 文件返回1.3. 其他2. 推荐教程1. 第四章：gin对于文件的上传和返回 ​ 文件的上传与下载对于一个网站来说往往十分必要的，例如用户头像或者其他文件的上传等等。而此处的处理方法便是当前端将文件传给后端时，后端对文件进行保存到特定的位置中。随后根据路由设置，对这些文件以某个url供外访问，当然也可交给前端访问了。 当然后端也可对路由进行设置，保证某些路由被访问时需要一定的信息，这样就可以保证一定的安全性了。（不过也是后话了。 ​ 于是本节主要分为两个小部分，即文件的上传与返回。 // TODO 参考代码可见api/v1/file.go 中 1.1. 文件上传 下面给了一部分代码，供参考 // CreateTutorial // @Summary 创建教程 // @Description 创建一个教程，一个教程目前等价于一个markdown文件 // @Tags 教程模块 // @Accept multipart/form-data // @Produce json // @Param x-token header string true \"token\" // @Param file formData file true \"教程文件\" // @Param data body model.CreateTutorialQ true \"组织ID，教程名称，教程简介，可读权限，可写权限\" // @Success 200 {object} model.CommonA \"是否成功，返回信息\" // @Router /api/v1/tutorials [post] func CreateTutorial(c *gin.Context) { // 获取请求数据 var data model.CreateTutorialQ if err := c.ShouldBind(&data); err != nil { c.JSON(http.StatusOK, model.CommonA{Success: false, Message: \"请求参数非法\"}) return } // 新建教程 tutorial := model.Tutorial{Name: data.Name,} if err := service.SaveTutorial(&tutorial); err != nil { c.JSON(http.StatusOK, model.CommonA{Success: false, Message: \"创建教程失败\"}) return } if err := c.SaveUploadedFile(data.File, thePath )); err != nil { // 回滚数据库 _ = service.DeleteTutorialByID(tutorial.ID) global.LOG.Panic(err) } c.JSON(http.StatusOK, model.CommonA{Success: true, Message: \"创建教程成功\"}) } 在主函数25行上，使用c.SaveUploadedFile 来保存文件，其中data.File 便是前端所传来的文件了，而后面的参数也是文件的具体保存路径。也即是上文所说的特定位置。 若是err为空则是保存成功，否则保存失败，本API中在21行创建了tutorial 的数据库表项。若是发生了文件错误，此处认为保存失败，也是删除对应的数据库表项。 实际使用中也可对文件的最大空间、允许文件的后缀等多个方面去限制文件上传，此处不多做演示了。 以上便是完成了文件的上传部分。那么要怎么找到对应的文件呢，此处的解决办法是利用路由设置，对指定的文件夹内文件可被特定的url所访问到。 当前端访问特定的url时，或可通过后端的验证便可访问到指定文件了。（具体限制在中间件部分细说） 1.2. 文件返回 路由规则如下 resourceRouter := basicRouter.Group(\"/resource\"){ resourceRouter.Static(\"/image\",imagePath ) } 第一行代表对路由进行分组，而下面则是控制指定路由对url的访问了。其中参数1便是路由、参数2便是保存位置了。个人大多直接指定绝对地址进行保存。 rootPath, err := os.Executable() if err != nil { panic(\"初始化失败：可执行程序路径获取失败\") } rootPath = filepath.Dir(rootPath) imagePath := filepath.Join(rootPath, \"resource\", \"image\") 保存成功后，若resourceRouter 的路由为127.0.0.1:8081/api/v1/resource ，则可通过127.0.0.1:8081/api/v1/resource/image+文件名访问到指定文件了。 而后端则可以在返回json中给明特定文件的url即可。下图为我上传了一个1.pdf 文件，当访问指定路由url时，IDM提示我下载该文件。 1.3. 其他 在本地测试时，个人目前所知两种相对方便的做法 在swagger中配置// @Param file formData file true \"教程文件\" 的注释，便可在swagger中上传文件 使用postman的formData中选择File模式即可 2. 推荐教程 官方文档 https://gin-gonic.com/zh-cn/docs/examples/upload-file/ By BFlameSwift，使用知识共享 署名-相同方式共享 4.0协议发布            updated 2022-10-22 07:49:13 "},"post-basis/p5-middleware-router-group.html":{"url":"post-basis/p5-middleware-router-group.html","title":"第五章 路由分组与中间件","keywords":"","body":"1. 第五章 路由分组与中间件1. 第五章 路由分组与中间件 本章节会简单介绍一些路由分组，以及一些中间件的使用。主要则是在路由分组中，使用中间件对路由进行简单划分。后续有时间会补充一些其他的中间件。 关于路由分组，参见大多数的写法，我将之放在router/router.go 中，首先在main.go 中，有着如下代码创建了最基本的路由 // 创建Router r := gin.New() initialize.InitRouter(r) 随后在具体的InitRouter 中，大体结构便如下所示。 首先进行跨域配置，此处简单只是进行了默认的跨域配置。 并用r.Use(cors.New(config)) 来应用。 也即r的所有路由都遵守这个规则。 func InitRouter(r *gin.Engine) { //跨域配置 config := cors.DefaultConfig() config.AllowAllOrigins = true config.AllowHeaders = append(config.AllowHeaders, \"x-token\") r.Use(cors.New(config)) r.GET(\"/swagger/*any\", ginSwagger.WrapHandler(swaggerFiles.Handler)) r.GET(\"/hello\", HelloGin) // 禁用代理访问 if err := r.SetTrustedProxies(nil); err != nil { global.LOG.Panic(\"初始化失败：禁止使用代理访问失败\") } // 登录模块 rawRouter := r.Group(\"/api/v1\") { rawRouter.POST(\"/login\", v1.Login) } } 而路由分组则是如下，根据路由规则以及自己的喜好设置路由路径。 其中POST便是代表使用POST方法来访问该路由时，调用相应的API。 // 登录模块 rawRouter := r.Group(\"/api/v1\") { rawRouter.POST(\"/login\", v1.Login) } 而中间件呢，此处首先使用自行定义的验证模块，Auth 其作用为当前端发来请求时，检测请求中的x-tokens，若违规或是确实该关键词便直接返回用户未登录的信息。 basicRouter := rawRouter.Group(\"/\") basicRouter.Use(middleware.AuthRequired()) 其中middleware.AuthRequired() 如下。大体内容则是先验证token的存在合理性。随后到数据库中检查是否存在该用户。 func AuthRequired() gin.HandlerFunc { return func(c *gin.Context) { token := c.GetHeader(\"x-token\") id, err := utils.ValidateToken(token) if err != nil { c.JSON(http.StatusOK, gin.H{\"success\": false, \"message\": \"用户校验失败\"}) c.Abort() return } if user, notFound := service.GetUserByID(id); notFound { c.JSON(http.StatusOK, gin.H{\"success\": false, \"message\": \"用户不存在\"}) c.Abort() } else { c.Set(\"user\", user) } } } 由此，在basicRouter 路由组下设置的路由，均要通过用户验证后方可访问。不过用户验证的API接口utils.ValidateToken(token) 的具体使用，还需要在讲解jwt的使用中细说。不过原理很简单，便是对用户的个人信息，例如uid 或是用户名等其他信息进行加密，随后后端再进行解密出token中的信息。当然加密时应包含一段代码中不易猜得的独立信息随之加密。否则便易于破解。 具体当Gin-demo 完结时可参见jwt部分。 推荐官方文档的中间件教程 https://gin-gonic.com/zh-cn/docs/examples/using-middleware/ By BFlameSwift，使用知识共享 署名-相同方式共享 4.0协议发布            updated 2022-10-22 07:49:13 "},"post-basis/p6-middleware-log-and-logrus.html":{"url":"post-basis/p6-middleware-log-and-logrus.html","title":"第六章 日志介绍以及工具推荐","keywords":"","body":"1. 第六章 日志介绍以及工具推荐2. 参考1. 第六章 日志介绍以及工具推荐 当项目部署到服务器上运行时，很有可能出现后端在某次服务中出现了问题。但是我们若不是用户告知恐怕很难发现这个错误。这时便需要日志的出场了。由日志为我们记下访问的信息以供后续调试。 当然Gin自带了Logger可以在控制台上输出一些访问以及异常记录。当运行后便后下图所示结果 但是其只能显示在shell中却不能记录下来。而本例中将会使用Logrus来作为中间件记录日志。 在middleware/logrus.go 中添加如下代码，并使用此中间件， 即在router/router.go 中添加r.Use(middleware.LoggerToFile()) func LoggerToFile() gin.HandlerFunc { logFilePath := global.VP.GetString(\"root_path\") logFileName := \"demo.log\" //日志文件 fileName := path.Join(logFilePath, logFileName) //写入文件 src, err := os.OpenFile(fileName, os.O_WRONLY|os.O_CREATE|os.O_APPEND|os.O_SYNC, 0666) if err != nil { fmt.Println(\"err\", err) } //实例化 logger := logrus.New() //设置输出 logger.Out = src //设置日志级别 logger.SetLevel(logrus.DebugLevel) //设置日志格式 logger.SetFormatter(&logrus.JSONFormatter{ TimestampFormat:\"2006-01-02 15:04:05\", }) return func(c *gin.Context) { // 开始时间 startTime := time.Now() // 处理请求 c.Next() // 结束时间 endTime := time.Now() // 执行时间 latencyTime := endTime.Sub(startTime) // 请求方式 reqMethod := c.Request.Method // 请求路由 reqUri := c.Request.RequestURI // 状态码 statusCode := c.Writer.Status() // 请求IP clientIP := c.ClientIP() // 日志格式 logger.Infof(\"| %3d | %13v | %15s | %s | %s |\", statusCode, latencyTime, clientIP, reqMethod, reqUri, ) } } // https://github.com/xinliangnote/go-gin-api 为了方便使用者读取我将其改为了json格式，随后访问swagger界面，可在demo.log见到如下日志 随后我又根据参考在log上更改了一些，具体请见Gin-Demo/middleware/logrus.go 中。 不过由于使用了gin.Default() 导致目前无法捕获异常放置到日志中，而是随着默认Recovery输出到了终端上。后续会介绍如何使用中间件捕获异常。 2. 参考 go-gin-api-document https://github.com/xinliangnote/go-gin-api https://www.yuque.com/xinliangnote/go-gin-api/ngc3x5 By BFlameSwift，使用知识共享 署名-相同方式共享 4.0协议发布            updated 2022-10-22 07:49:13 "},"post-basis/p7-gorm-basic-and-service.html":{"url":"post-basis/p7-gorm-basic-and-service.html","title":"第七章：初识GROM使用GORM进行数据库操作","keywords":"","body":"1. 第七章：初识GROM使用GORM进行数据库操作1.1. 第七章：初识GROM使用GORM进行数据库操作1.1.1. Gorm的具体使用1.1.2. 模型定义1.1.3. 高级查询1.1.4. 原生SQL查询1.1.5. Hook1.1.6. 事务处理1.2. 总结1.3. 参考1. 第七章：初识GROM使用GORM进行数据库操作 1.1. 第七章：初识GROM使用GORM进行数据库操作 ORM（对象关系映射）可以在关系型数据库与对象之间建立映射，可以想操纵对象一样操作数据库。而在Go中，我所指的有Gorm与Beego ORM两种ORM库用一操作数据库。而本Book中选择Gorm。 为什么选择Gorm Gorm是Go语言中的一个性能较好的ORM库。对开发人员友好，功能强大，调用方便。许多大厂都在使用[1]。 此外还有一些特点： 支持关联（Has one Has Many….) 支持预加载 支持Hook（增删改查前后进行操作） 支持事务处理。（很重要） 不过由于我没用过Beego ORM，就不妄自评论了 Gorm的安装 go get -u github.com/gorm.io/gorm 1.1.1. Gorm的具体使用 数据库连接 由于Mysql的普遍性，此处以Mysql为例进行数据库连接 首先预定义好特定的字符串，使用如下代码即可连接，在Gin-demo 中，使用读取yml文件的方式，来避免敏感信息泄露。 dsn := fmt.Sprintf(`%s:%s@tcp(%s)/%s?charset=utf8&parseTime=%t&loc=%s`, username, password, host, database, true, \"Local\") db, err := gorm.Open(mysql.Open(dsn), &gorm.Config{}) if err != nil { panic(\"failed to connect database\") } 在实际使用数据库中，大致可以归类为一下六种操作[3] 数据库表结构迁移 // 1. Auto migration for given models db.AutoMigrate(&Product{}) 不过该操作也只能对新增的字段进行变更。却不会删除字段 插入数据 // 2. Insert the value into database if err := db.Create(&Product{Code: \"D42\", Price: 100}).Error; err != nil { log.Fatalf(\"Create error: %v\", err) } PrintProducts(db) 使用Create 方法创建记录，通过返回错误检查是否成功插入。 获取某个符合条件的数据 // 3. Find first record that match given conditions product := &Product{} if err := db.Where(\"code= ?\", \"D42\").First(&product).Error; err != nil { log.Fatalf(\"Get product error: %v\", err) } 使用First方法返回符合记录的第一条数据，将返回数据存储于product中。 更新数据表项 // 4. Update value in database, if the value doesn't have primary key, will insert it product.Price = 200 if err := db.Save(product).Error; err != nil { log.Fatalf(\"Update product error: %v\", err) } PrintProducts(db) 使用Save方法，来把变量product中所有于数据库中不一样的字段更新到数据库中。此处更新了Price并保存到数据库中。 删除某表项 // 5. Delete value match given conditions if err := db.Where(\"code = ?\", \"D42\").Delete(&Product{}).Error; err != nil { log.Fatalf(\"Delete product error: %v\", err) } PrintProducts(db) 使用Delete方法，来把product从对应的数据库表中删除 不过gorm同样支持批量删除， db.Where(\"name in (?)\",[]string{\"ceshi\",\"123\"}).Delete(&User{}) 获取一系列表记录 // List products func PrintProducts(db *gorm.DB) { products := make([]*Product, 0) var count int64 d := db.Where(\"code like ?\", \"%D%\").Offset(0).Limit(2).Order(\"id desc\").Find(&products).Offset(-1).Limit(-1).Count(&count) if d.Error != nil { log.Fatalf(\"List products error: %v\", d.Error) } log.Printf(\"totalcount: %d\", count) for _, product := range products { log.Printf(\"\\tcode: %s, price: %d\\n\", product.Code, product.Price) } } 该方法可以获取到一系列的记录，根据Offset Limit Order来调整返回顺序等。 1.1.2. 模型定义 // User 用户 type User struct { ID uint64 `gorm:\"primary_key; autoIncrement; not null;\" json:\"id\"` Name string `gorm:\"size:32; not null;\" json:\"name\"` Email string `gorm:\"size:32; not null; unique;\" json:\"email\"` Password string `gorm:\"size:128; not null;\" json:\"password\"` Avatar string `json:\"avatar\"` Profile string `gorm:\"size:256;\" json:\"profile\"` RegTime time.Time `gorm:\"autoCreateTime\" json:\"regTime\"` UpdatedAt time.Time `gorm:\"autoUpdateTime; not null;\" json:\"updatedAt\"` } 在模型定义后，随后使用db.AutoMigrate(&User{}) 后运行，即可将生成表到数据库中。在Gin-demo 项目中则位于initialize/gorm.go中。 此处只是做一个简单实例，并不介绍大多情况。实际使用时可参照此或者其他项目亦或是官方文档来使用。 1.1.3. 高级查询 此处介绍四种高级检索 对检索记录进行排序 // SELECT * FROM users ORDER BY age desc, name; db.Order(\"age desc, name\").Find(&users) Limit & Offset Offset 指定从第几条记录开始查询，Limit 指定返回的最大记录数。Offset 和 Limit 值为 -1 时，消除 Offset 和 Limit 条件。另外，Limit 和 Offset 位置不同，效果也不同。 // SELECT * FROM users OFFSET 5 LIMIT 10; db.Limit(10).Offset(5).Find(&users) Distinct 可以从数据库记录中选择不同的值。 db.Distinct(\"name\", \"age\").Order(\"name, age desc\").Find(&results) Count 可以获取匹配的条数。 var count int64 // SELECT count(1) FROM users WHERE name = 'jinzhu'; (count) db.Model(&User{}).Where(\"name = ?\", \"jinzhu\").Count(&count) 1.1.4. 原生SQL查询 基本用法如下， type Result struct { ID int Name string Age int } var result Result db.Raw(\"SELECT id, name, age FROM users WHERE name = ?\", 3).Scan(&result) 1.1.5. Hook Hook即钩子，下面代码为在插入记录之前的所执行的Hook， (u *User) 表示对User结构体的方法 func (u *User) BeforeCreate(db *gorm.DB) (err error) { u.UUID = uuid.New() if u.Name == \"admin\" { return errors.New(\"invalid name\") } return } 1.1.6. 事务处理 Gorm的事务处理也比较简单，使用db.Begin() 开启事务，使用tx.Commit()方法结束事务。异常时使用tx.Rollback()回滚。有如下示例代码 //开启事务 tx := db.Begin() GormUser := GormUser{ Phone: \"18888888888\", Name: \"Shirdon\", Password: md5Password(\"666666\"), //用户密码 } if err := tx.Create(&GormUser).Error; err != nil { //事务回滚 tx.Rollback() fmt.Println(err) } db.First(&GormUser, \"phone = ?\", \"18888888888\") //事务提交 tx.Commit() 1.2. 总结 Go项目中，本例使用Gorm进行数据库的CURD操作。而Gorm同样也是相对非常受欢迎的ORM框架。本章提供了Gorm的大多数操作方式并包括高级检索、事务处理、Hook等。这三种操作在实际使用中非常有用。不过若是降低要求，只是掌握了CURD基本操作在小型后端上已经可以一试了。 1.3. 参考 极客时间：Go项目开发实战：30 Gorm 六种操作源码 By BFlameSwift，使用知识共享 署名-相同方式共享 4.0协议发布            updated 2022-10-22 07:49:13 "},"post-basis/p8-jwt-go-use.html":{"url":"post-basis/p8-jwt-go-use.html","title":"第八章 jwt-go详细教学及使用示例","keywords":"","body":"1. 第八章 jwt-go详细教学及使用示例1.1. 什么是JWT1.1.1. JWT的安装1.2. JWT的使用1.3. 将JWT应用于中间件中1.3.1. 简单实践1.4. 参考1. 第八章 jwt-go详细教学及使用示例 ​ 在前面的各章学习交流后，相信你已经可以写出一个小型后端了，并在开发服务器上运行起来了。但是我们现在仍存在一个问题，就是这些API接口并没有鉴权功能，即所有知道后端地址的人都可以请求该项目的API接口与Swagger文档。甚至可能被网络的端口扫描器所扫描到而滥用。因此我们需要对API接口进行访问控制。 ​ 个人所知的API访问控制有两种，OAuth2.0 与JWT .由于这而这完全不同，此处还是使用更轻量化的JWT来实现API的访问控制功能。 1.1. 什么是JWT JWT：Json Web Token，用来在各方用Json对象安全的传输信息，并且由于此信息经过了数字签名，因此该信息可以被信任。 JWT内部由. 分为三部分：Header Payload Signature 分别是头部，有效信息，签名。 ​ 头部介绍令牌类型与使用的签名算法。而Payload则是一个Json对象，表示JWT中实际传输的数据。在签名中则是对前两个部分进行的签名，从而校验消息在整个过程中是否被篡改，对于私钥签名的令牌，还可以验证JWT的发送者是否是真实身份。 典型的认证过程如下，用户登录后，Server像前端发送指定tokens，前端将其存储在Cookie或是localstorage中并在后续每次操作都携带Token，Server端收到请求后便会验证Token，进行鉴权，进行业务逻辑处理。 1.1.1. JWT的安装 go get -u github.com/golang-jwt/jwt@latest 1.2. JWT的使用 使用如下代码生成一个token，其中jwt.StandardClaims为jwt-go中预定义的一些字段，此处只使用两个，并把传来的userid,作为Audience 存储。对上述信息使用SHA256加密，紧接着利用配置文件中配置的server.secret ，来使用token.SignedString 方法生成签名字符串。 // GenerateToken 生成一个token func GenerateToken(id uint64) (signedToken string) { claims := jwt.StandardClaims{ Issuer: \"demo-server\", Audience: strconv.FormatUint(id, 10), } token := jwt.NewWithClaims(jwt.SigningMethodHS256, claims) secret := global.VP.GetString(\"server.secret\") signedToken, err := token.SignedString([]byte(secret)) if err != nil { panic(\"GenerateToken: sign token error\") } return } 当用户登录时，即可通过上述方法，传入指定用户的id后生成对应的token。由于其中使用了私钥secret，可以保证安全性。 当前端将获取到token后在此发来请求，后端便可对此token进行解析验证。具体代码如下，解析token后获得到某用户的uid，从而得到具体的用户正在使用。 // ParseToken 验证token的正确性，正确则返回id func ParseToken(signedToken string) (id uint64, err error) { secret := global.VP.GetString(\"server.secret\") token, err := jwt.Parse( signedToken, func(token *jwt.Token) (interface{}, error) { return []byte(secret), nil }, ) if err != nil || !token.Valid { err = errors.New(\"token isn't valid\") return } id, err = strconv.ParseUint(token.Claims.(jwt.MapClaims)[\"aud\"].(string), 10, 64) if err != nil { err = errors.New(\"token isn't valid\") } return } 上述代码位于Gin-Demo/utils/auth.go中 1.3. 将JWT应用于中间件中 鉴权若是后端每需要便要调用一次还是比较麻烦的，为此我们将鉴权引入到中间件中，对特定的组路由（GroupRouter）应用此中间件，即可对该组路由对应的API接口进行鉴权。 下图为middleware/auth.go中的代码，通过提取gin上下文中的头部x-token字段,来进行参数验证。若是用户校验失败，则表示前端的token不合法而返回。解析成功后，得到token内部的uid，检测数据库中不存在此用户，同样也是不合法而返回。最终使用c.Set(\"user\", user)，将用户结构体放在上下文中。以便后续直接获取到用户。 func AuthRequired() gin.HandlerFunc { return func(c *gin.Context) { token := c.GetHeader(\"x-token\") id, err := utils.ParseToken(token) if err != nil { c.JSON(http.StatusOK, gin.H{\"success\": false, \"message\": \"用户校验失败\"}) c.Abort() return } if user, notFound := service.GetUserByID(id); notFound { c.JSON(http.StatusOK, gin.H{\"success\": false, \"message\": \"用户不存在\"}) c.Abort() } else { `c.Set(\"user\", user)` } } } 在上述将user放入到上下文后，即可通过此方法在各API中来一步获取到当前用户了。 func SolveUser(c *gin.Context) database.User { userRaw, _ := c.Get(\"user\") return userRaw.(database.User) } user := utils.SolveUser(c) 1.3.1. 简单实践 在router中配置路由，并添加API：GetUser ，测试不加token以及使用正确token的返回结果。通过结果可知测试成功 // 除了登录模块和静态资源之外，都需要身份认证 basicRouter := rawRouter.Group(\"/\") basicRouter.Use(middleware.AuthRequired()) // 用户模块 userRouter := basicRouter.Group(\"/users\") { userRouter.GET(\"/:id\", v1.GetUser) } func GetUser(c *gin.Context) { // 获取请求数据 id, err := strconv.ParseUint(c.Param(\"id\"), 10, 64) if err != nil { c.JSON(http.StatusOK, response.GetUserA{Success: false, Message: \"请求参数非法\", Code: 400}) return } // 查询对应ID的用户 if user, notFound := service.GetUserByID(id); notFound { c.JSON(http.StatusOK, response.GetUserA{Success: false, Message: \"找不到对应的用户\", Code: 404}) } else { // 返回响应 c.JSON(http.StatusOK, response.GetUserA{Success: true, Message: \"查找成功\", Name: user.Name, Code: 200}) } } 1.4. 参考 Matrix53 phoenix server jwt-go By BFlameSwift，使用知识共享 署名-相同方式共享 4.0协议发布            updated 2022-10-22 07:49:13 "},"post-advanced/introduction.html":{"url":"post-advanced/introduction.html","title":"Introduction","keywords":"","body":"1. Introduction1. Introduction 该部分其实对于后端开发上可能没有什么帮助，更多的带有一丝炫技的意味在里面，可能只是答辩的时候简单吹嘘一下吧。 在Gin-demo中我也会将之前的部分与这部分进阶篇的代码所区分开处理，以便不想使用这部分的同学不被影响到。 By BFlameSwift，使用知识共享 署名-相同方式共享 4.0协议发布            updated 2022-10-22 07:49:13 "},"post-advanced/exception-capture-processing.html":{"url":"post-advanced/exception-capture-processing.html","title":"异常捕获处理","keywords":"","body":"1. Exception capture processing1. Exception capture processing By BFlameSwift，使用知识共享 署名-相同方式共享 4.0协议发布            updated 2022-10-22 07:49:13 "},"post-advanced/interface-flow-limiting-control.html":{"url":"post-advanced/interface-flow-limiting-control.html","title":"接口限流控制","keywords":"","body":"1. Interface flow limiting control1. Interface flow limiting control By BFlameSwift，使用知识共享 署名-相同方式共享 4.0协议发布            updated 2022-10-22 07:49:13 "},"post-advanced/unified-timeout-control.html":{"url":"post-advanced/unified-timeout-control.html","title":"统一超时控制","keywords":"","body":"1. Unified timeout control1. Unified timeout control By BFlameSwift，使用知识共享 署名-相同方式共享 4.0协议发布            updated 2022-10-22 07:49:13 "},"gossip/pn1-elasticsearch-basic-guide.html":{"url":"gossip/pn1-elasticsearch-basic-guide.html","title":"elasticsearch go操作简单指北","keywords":"","body":"1. elasticsearch go操作简单指北1.1. 杂谈1：elasticsearch go操作简单指北1.1.1. 数据来源1.1.2. 数据导入1.1.3. 数据检索1.1.4. es服务调优教程推荐1.2. 总结1. elasticsearch go操作简单指北 1.1. 杂谈1：elasticsearch go操作简单指北 本节偏向于杂谈，适用于软院大三后端使用elasticsearch的同学 由于本Ginbook大概也只是面向软件学院初学后端的大二同学。众所周知近年来软院大三的软工2的大作业都是学术共享平台，即针对论文等学术成果进行统一管理的项目。具体要求可能有变化不变透露，不过可以观看我们组的演示视频，引流。而后端上主要则是对海量数据的各种检索，结果聚合。并加以展示。而其中用的最多的便是elasticsearch 了。 凭借着对着elasticsearch 弄了很久，想着以后若不从事相关方面就无用了。便以该学术共享平台的一些操作为例留一点初步操作方法传下去。为后续同学们有一个明确的上手方向吧。 其中elasticsearch所使用的go库为\"github.com/olivere/elastic/v7\"，版本或有不同，大致原理想必相同。 1.1.1. 数据来源 其中主要是paper数据的来源，这部分我在SlimeScholar-go中介绍了。个人庆幸的是在2021年微软的大而全的microsoft academic graph还在运行中，经过多次与官方发邮件后才获取到Azure的共享并下载。下面是个人使用过的一些建议吧。仅供参考，相信可以满足大多数要求了。值得一提的是开发当时还算火的Readpaper,也是用的MAG数据，相信从id一样上就可以看出来。 OpenAlex将会是未来的第一选择。（MAG已宣布在2021年末停止服务。） 下面推荐几款个人在筛选中觉得还不错的数据（排名按照个人使用情况以及推荐度排序）： OpenAlex : 或许是MAG 的最好替代品。 SemanticScholar ： 个人觉得非常牛的数据了，（不算mag的话）。唯一的缺点个人觉得就是没有机构以及领域的数据。会议的数据个人觉得还是相对无关紧要的。** 数据每月更新：** 虽然大多优秀的网站都是如此。总数据量大概在2.1亿左右 400G?（2021年11月统计），就连超级全的mag也只有2.6亿。在数据量上可以随便秒杀一大多常规数据了。但也因为以上痛点个人还是最终选择了 mag 此外此网站还有一些比较好用的API在链接处。至于数据源则是在此 OAG2.1：from aminer 但是相对较旧，没有最新一年的数据。但是是微软MAG前几年的版本 scigraph ：看起来还算不错。应该涵盖了大部分的CSpaper Unpaywall :较优秀的开源数据网站，填写表格即可拿到数据。 解压后大概在130G。不过此时我已有mag便没有过多了解，但是很多数据网站均有提到此网站 最后来一个百家汇，是个列举开源数据网站的网站，虽然以上只有scigraph是我在这里发现的，但是不可否认这个网站还是比较全面的。https://shubhanshu.com/awesome-scholarly-data-analysis/#networks 1.1.2. 数据导入 由于当时MAG给出的格式并不是json，而是基于 分割的字符串。每一行代表一个实体，为了操作方便我首先将其都转化为json格式。（不建议用python，较慢，此处使用Go。 在Go中对于Json数据，我直接将其转化为map[string]interface{},使用bulk 批量插入。个人偏好于每次插入10000条，或是每次操作2-5s的样子。2.6亿的数据插入到服务器中往往还受限于带宽(也可能局限于磁盘IO) ，大概在一整天左右。 bulkRequest := client.Bulk() { var m map[string]interface{} = make(map[string]interface{}) err = json.Unmarshal([]byte(json_str), &m) if err != nil {panic(err)} doc := elastic.NewBulkIndexRequest().Index(index).Id(m[\"id\"].(string)).Doc(m) bulkRequest.Add(doc) } response, err := bulkRequest.Do(context.Background()) 此外，由于elasticsearch的特性，导致多表联查的工作异常困难。考虑到后续还需要进行搜索结果的聚合，因此大多关键数据我都将其整合到Paper实体中。具体各数据参数可参见：MAG, OpenAlex 于是我将 Paper Author Affiliations、 Paper Fields of Study 、Paper Abstracts Inverted Index 使用NewBulkUpdateRequest 来批量更新到Paper中，即通过主键与将论文作者，论文领域、论文及其摘要的关系插入到Paper这张“表”中。让Paper变成一张完整大表。随后已有的搜索便都可以进行了。包括但不限于：按照：篇名、摘要、篇关摘、文献类型、领域、作者、作者机构、文献出版来源、文献Journal来源、文献Conference来源进行搜索。以及初步高级检索。并对每一个的结果进行聚合并筛选操作。 而NewBulkUpdateRequest则是可以根据主键，将当前的各属性，找到不同的屬性添加到被添加的主体中。避免由于数据过大而无法在内存中操作的问题。（不过速度缓慢，上述操作大概三四天的样子） 不过大致遇到困难的时候才会想起来吧 doc := elastic.NewBulkUpdateRequest().Index(index).Id(id).Doc(m).DocAsUpsert(false) 所谓聚合便是类似知网这样的： 1.1.3. 数据检索 为了方便此处简单介绍一下，由于Go中elasticsearch是以对象操作的，相比于python我了解到的则是直接制造es所需要的json格式，由于过于繁琐此处不放出。简单介绍一下下面的字段。 searchResult, err = Client.Search(index).Query(boolQuery).Size(size).TerminateAfter(utils.TERMINATE_AFTER).Aggregation(\"conference\", conference_agg).Aggregation(\"journal\", journal_id_agg).Aggregation(\"doctype\", doc_type_agg).Aggregation(\"fields\", fields_agg).Aggregation(\"publisher\", publisher_agg).Aggregation(\"min_year\", min_year_agg).Aggregation(\"max_year\", max_year_agg).Sort(\"citation_count\", ascending).From((page - 1) * size).Do(context.Background()) for _, hit := range searchResult.Hits.Hits { paperIds = append(paperIds, hit.Id) } Search(index)： 按照指定的index搜索，例如paper Query(boolQuery)，根据指定的查询检索，此处使用的是bool查询，为一个比较高级的查询，大多查询均可被囊括。 Size(size)：每次返回几个，由于搜索习惯我一般设置为10.即每页返回10个搜索结果。 TerminateAfter(utils.TERMINATE_AFTER)： 此字段为匹配到多少结果后停止。由于elasticsearch的匹配机制。对于亿级别的大数据可能会匹配到上千万的文档，并对其进行相关度排序。对个人服务器而言优化做的不多当结果到了几千万的时候搜索便会到达10s，算是相当慢的水平了。此处设置匹配到1千万个文档便返回便是为了提高响应速度，又不大的影响结果。 Aggregation：表示聚合，即根据指定的属性，对相同数值进行聚合操作。即上图所示。具体有许多种聚合此处不一一列举。 .Sort：按照指定字段排序。 From 通过from、size即可实现分页查看。 Do 开始执行，一般为最后一个被调用的。 结果聚合 具体操作可参见SlimeScholar-go 的412行附近。不做赘述。 1.1.4. es服务调优教程推荐 腾讯云大佬讲解，非常多受用之处。 1.2. 总结 大致简单回顾了个人使用elasticsearch的一些操作。不过写的略草。不过是一带而过。希望都是针对一些比较关键的信息，能让你在软工2使用es时有一定帮助。另外在es遇到关键问题也可发issue或联系bflameswift By BFlameSwift，使用知识共享 署名-相同方式共享 4.0协议发布            updated 2022-10-22 07:49:13 "},"post-gossip/github-action.html":{"url":"post-gossip/github-action.html","title":"利用Github Action 自动部署","keywords":"","body":"1. 利用Github Action 自动部署Go项目1.1. 简介2. Github Action自动部署2.1.1. 准备工作3. 基于Air的热加载3.1. Air的配置4. 参考1. 利用Github Action 自动部署Go项目 1.1. 简介 Github 针对开发者提供了很多免费的实用工具，Github Action 就是其中之一。你可以将其理解为一个特殊的脚本，在满足一定条件的时候它就会执行（例如检测到对某一分支的push，到达了一天的0点等）。 在网站开发中，后端经常需要把刚写完的内容同步至服务器端供前端测试，如果手动部署，则需要先连接服务器，然后git pull，再将后端运行起来。一次两次还好，多了之后会很浪费时间且比较枯燥。适当使用 Github Action 就可以把这个过程自动化，下面将介绍如何实现自动部署。 而由于本人的生疏不足，因此此处介绍两种常用的方法进行自动化部署。第一种较为常见，类似DjangoBook-GithubAction不借助外部工具的部署方案，另一种则是使用Go的工具Air来对Go项目进行热加载，即自动编译、重启程序，也可以达到自动部署的作用。 2. Github Action自动部署 ​ 2.1.1. 准备工作 事实上，Go项目（此处以一Gin项目为例）的部署，就是在服务器上关掉之前的后端服务，并重新打包go build main.go 并运行项目./main & 即可。不过在自动化部署中，需要做到登录到服务器，并执行相应命令。 在Commit触发workflow之前，首先需要配置Secrets,以下关于配置Secret的操作直接摘自Marvolo’s Djangobook 进入Github 里对应的仓库页面，点击Settings->Secrets（如果找不到Secrets，可能是权限不够，可以让仓库拥有者来操作）。这里存放的是这个仓库中的所需要的不对外公开的常量。点击创建新 Secrets： 然后分别填入常量名和值： 这个时候就不能再看到这个常量的值了，只能修改或者删除。之所以这么操作，是考虑到之后仓库可能改成 public，为了避免服务器的信息泄露，于是使用了 Secrets 来做一个安全防护。关于Github Action的更具体使用可以查询官方文档或是其他关于Github Action的教程吧。 个人目前的.github/workflows/build.yml 内容如下： name: build on: push: branches: [master] jobs: build: runs-on: ubuntu-latest steps: - name: setup run: sudo apt install sshpass - name: pull and build env: GO: /usr/local/go/bin/go run: | sshpass -p ${{secrets.PASSWORD}} ssh -o StrictHostKeyChecking=no root@${{secrets.IP}} \"cd /opt/Project/Gin-demo; git config --global http.postBuffer 1048576000;git pull; make kill; make dep; ps -ef | grep Gin-demo; ls ./scripts/; nohup make build_and_run\" 上面具体做了几件事： 登录到服务器 pull仓库 kill之前运行的程序make kill build-and-run make build_and_run 不过观察可以发现，workflow中在登录到服务器后，使用了一系列make 操作。 即将一些命令简化为make + *的格式，还是使用了Makefile，个人的配置如下，有了Makefile便可在开发中节省不少力气以及加快开发进程，具体更高级的Makefile使用可以去[1]中查看。 BINARY_NAME=Gin-demo # Github-action中指定go路径并使用更稳定 GO=/usr/local/go/bin/go build: GOARCH=amd64 GOOS=linux ${GO} build -o ${BINARY_NAME}-linux main.go # 根据文件名查找相应进程并kill kill: ps -ef | grep ${BINARY_NAME} | grep -v grep | awk '{print $2}' | xargs kill -9 run: ./${BINARY_NAME}-linux build_and_run: build run clean: ${GO} clean rm ${BINARY_NAME}-linux test: ${GO} test ./... test_coverage: ${GO} test ./... -coverprofile=coverage.out # 更新包 dep: ${GO} mod tidy vet: ${GO} vet lint: golangci-lint run --enable-all 然而之所以有第二种方法，还是因为这种流程下来，会导致运行后端./Gin-demo后，workflow 无法直接结束：等到Gin-demo结束。即便已经完成了一系列的操作，当然后端也已成功部署。在此也希望后续有人或是我自己能发现问题并改进吧。 3. 基于Air的热加载 ​ 关于Air的简单介绍与使用可以参见[2]， 简单来讲，若没有使用2，当修改了代码后，需要重新编译运行才能得到更新后的程序。而使用了air后，在命令行使用air 便可以运行程序，并能热更新程序，（类似Django） $ air 3.1. Air的配置 安装Air（当然，linux要设置好GOPATH并添加环境变量）[3] go install github.com/cosmtrek/air@latest Air的使用 初始化配置文件：在项目根目录下运行： air init ​ 随后得到了配置文件.air.toml，此时直接运行air 往往会向./tmp/目录下build文件，而与本Gin-demo默认为项目根目录的意味不符，于是我们修改配置文件 修改为如下代码即可 # Windows bin = \"main.exe\" cmd = \"go build -o ./main.exe .\" # linux bin = \"main\" cmd = \"go build -o ./main .\" 随后项目成功运行 而Linux上修改大致内容相同。 而服务器Linux上的剩余工作则很简单了，相应的GithubAction执行的命令是之前的子集，具体到pull代码下来即可。由于在服务器上实现使用air &，则在更新代码后由Air自动执行热重启。 name: build on: push: branches: [master] jobs: build: runs-on: ubuntu-latest steps: - name: setup run: sudo apt install sshpass - name: pull run: | sshpass -p ${{secrets.PASSWORD}} ssh -o StrictHostKeyChecking=no root@${{secrets.IP}} \"cd /opt/Project/Gin-demo; git config --global http.postBuffer 1048576000;git pull\" - name: query_backend_status # 查看后端运行情况 env: # go build得到的文件名 PROJ_NAME: main run: | sshpass -p ${{secrets.PASSWORD}} ssh -o StrictHostKeyChecking=no root@${{secrets.IP}} \"ps -ef | grep ${PROJ_NAME}\" 具体测试如下： 最新提交中，我将HelloGin的代码进行修改： 等到workflows结束后，访问ip:port,发现已经部署成功。此外经过在部署前后查看进程的PID发现，的确进程PID发生了变化，可见热重启发挥了作用。 相比较而言，使用Air进行部署的确简单快捷。 最后我在查询资料的途中，发现了另一种自动部署方法， 读者可以自行尝试，不过个人觉得原理类似，但是配置相对Air繁琐，不顾多赘述。 4. 参考 [1] Makefile使用 [2] Air 简单介绍 [3] 设置GOPATH [4] Air的简单使用 [5] 另一种Go项目自动部署方法 [6] Air配置文件详细介绍 [7] Marvolo’s Djangobook By BFlameSwift，使用知识共享 署名-相同方式共享 4.0协议发布            updated 2022-10-22 07:49:13 "},"post-gossip/tools.html":{"url":"post-gossip/tools.html","title":"Tools","summary":"部分方便使用的方法，避免重复造简单轮子","keywords":"","body":"1. Tools1. Tools import ( \"encoding/json\" \"math\" \"sort\" \"strconv\" \"strings\" \"time\" ) // TODO 泛型 func GetMapAllKey(m map[string]interface{}) []string { list := make([]string, 0, len(m)) for key := range m { list = append(list, key) } return list } func GetMapAllContent(m map[string]interface{}) []interface{} { list := make([]interface{}, 0, len(m)) for key := range m { list = append(list, m[key]) } return list } func StructToMap(s interface{}) (ret_map map[string]interface{}) { str, err := json.Marshal(s) if err != nil { panic(err) } err = json.Unmarshal([]byte(str), &ret_map) return ret_map } func GetMapKeysAndValues(m map[string]interface{}) (keys []string, values []interface{}) { for key := range m { keys = append(keys, key) values = append(values, m[key]) } return keys, values } // 对map 按照key 排序 func RankByWordCount(wordFrequencies map[string]int, ascending bool) PairList { pl := make(PairList, len(wordFrequencies)) i := 0 for k, v := range wordFrequencies { pl[i] = Pair{k, v} i++ } //从小到大排序 //sort.Sort(pl) //从大到小排序 if ascending { sort.Sort(pl) } else { sort.Sort(sort.Reverse(pl)) } return pl } type Pair struct { Key string Value int } type PairList []Pair func (p PairList) Len() int { return len(p) } func (p PairList) Less(i, j int) bool { return p[i].Value By BFlameSwift，使用知识共享 署名-相同方式共享 4.0协议发布            updated 2022-10-22 07:49:13 "},"post-gossip/foresight.html":{"url":"post-gossip/foresight.html","title":"Go-1.18展望","summary":"展望go1.18的新特性——泛型，并收集部分好用的新版本包。","keywords":"","body":"1. Go-1.18展望1. Go-1.18展望 Go的Lodash (咕咕~) By BFlameSwift，使用知识共享 署名-相同方式共享 4.0协议发布            updated 2022-10-22 07:49:13 "},"gossip/pn2-how-to-transplant-gin-demo.html":{"url":"gossip/pn2-how-to-transplant-gin-demo.html","title":"如何移植Gin-demo","keywords":"","body":"1. 如何移植Gin-demo1. 如何移植Gin-demo 虽说在Gin的介绍页 中提到Gin的一个轻量化框架，配置简单等。但是一路下来真正配置的还是很多。但是盛如Django在初学时好像也不需要讲究这么多文件结构等等。不过个人理解上，Django作为相对大而全的框架，你在使用时大多需要自零开始搭建架构，还需要配置很多东西。但是本例所用的Gin上，可以根据已有的项目结构进行快速移植为新项目使用。且配置大多中间件，文件结构清晰明了。此外，虽然本Ginbook讲的相对繁琐，但是包含了不少个人在学习后端一年所了解到的许多方便工具。许多部分，例如日志，jwt鉴权。如果不用后端同样可以进行。不过相对粗糙和鉴权繁琐罢了。 下面简单介绍一些如何将Gin-demo简单移植为你的后端项目。 全局搜索并替换github.com/Super-BUAA-2021/Gin-demo 为你想要的包名。 本例为了符合大多项目对于module的设置，以及方便其他人的使用。将module设置为此。也在使用service包都需要import \"github.com/Super-BUAA-2021/Gin-demo/service\" 。 全局搜索demo，并替换你想要的项目名。包括但不限于：日志文件名，配置文件名 main.go更改Swagger注释更改为个人以及项目信息，并更新后端运行端口号。 在配置文件中更改为你自己的数据库以及jwt-secret等信息。 相信完成上述四步，运行main便可将此移植为你的项目了 By BFlameSwift，使用知识共享 署名-相同方式共享 4.0协议发布            updated 2022-10-22 07:49:13 "}}